---
import NewLayout from "@layouts/NewLayout.astro";
import NewNavbar from "@components/new-design/NewNavbar.astro";

export async function getStaticPaths() {
  return [
    { params: { slug: 'react-server-components' } },
    { params: { slug: 'design-systems' } },
    { params: { slug: 'terminal-workflows' } },
  ];
}

const { slug } = Astro.params;

// Mock data - in a real app, this would come from a CMS or markdown files
const posts = {
  'react-server-components': {
    title: 'El Futuro de React Server Components',
    date: 'Oct 12, 2023',
    readTime: '5 min',
    category: 'Engineering',
  },
  'design-systems': {
    title: 'Construyendo Sistemas de Diseño Escalables',
    date: 'Sep 28, 2023',
    readTime: '7 min',
    category: 'Design',
  },
  'terminal-workflows': {
    title: 'Dominando Flujos de Trabajo en Terminal',
    date: 'Aug 15, 2023',
    readTime: '6 min',
    category: 'Productivity',
  },
};

const post = posts[slug as keyof typeof posts];
---

<NewLayout
  title={`${post.title} - Ivan Mercedes`}
  description={post.title}
  type="article"
>
  <NewNavbar />
  <main class="pt-32 pb-24">
    <div class="max-w-3xl mx-auto px-6">
      <a href="/new/blog" class="group inline-flex items-center gap-2 text-sm text-neutral-500 hover:text-white mb-10 transition-colors">
        <span class="p-1 rounded-md bg-white/5 border border-white/5 group-hover:bg-white/10 transition-colors">
          <span class="iconify" data-icon="lucide:arrow-left" data-width="14"></span>
        </span>
        Volver a escritos
      </a>

      <article>
        <div class="mb-10">
          <div class="flex items-center gap-3 text-xs font-mono text-neutral-500 mb-6">
            <span>{post.date}</span>
            <span class="w-1 h-1 rounded-full bg-neutral-700"></span>
            <span>{post.readTime} lectura</span>
            <span class="w-1 h-1 rounded-full bg-neutral-700"></span>
            <span class="text-indigo-400">{post.category}</span>
          </div>
          <h1 class="text-3xl md:text-5xl font-medium text-white tracking-tight mb-8 leading-[1.1]">
            {post.title}
          </h1>
        </div>

        <!-- Featured Image Placeholder -->
        <div class="w-full h-[400px] rounded-xl bg-neutral-900 border border-white/5 mb-12 overflow-hidden relative">
          <div class="absolute inset-0 bg-grid opacity-30"></div>
          <div class="absolute inset-0 bg-gradient-to-t from-neutral-950/80 to-transparent"></div>
          <div class="absolute bottom-6 left-6 right-6">
            <div class="flex items-center gap-2 mb-2">
              <div class="w-3 h-3 rounded-full bg-cyan-500 shadow-[0_0_10px_rgba(6,182,212,0.5)]"></div>
              <div class="h-px w-20 bg-cyan-500/50"></div>
            </div>
            <div class="font-mono text-xs text-cyan-400">System Architecture v2.0</div>
          </div>
        </div>

        <!-- Prose Content -->
        <div class="prose text-neutral-400 max-w-none">
          <p class="text-lg leading-relaxed text-neutral-300">
            El panorama del desarrollo web está experimentando un cambio tectónico. Con la introducción de React Server Components (RSC), nos estamos alejando de los modelos de hidratación centrados en el cliente de la última década hacia un futuro híbrido que aprovecha lo mejor del servidor y el cliente.
          </p>

          <h2>El Cambio en el Modelo Mental</h2>
          <p>
            Tradicionalmente, los desarrolladores de React han tratado el servidor como una simple capa de API. Los componentes eran funciones puras de estado, ejecutándose casi exclusivamente en el navegador. Si bien esto permitió una rica interactividad, introdujo el problema de la "cascada": la obtención de datos encadenada a través de jerarquías de componentes.
          </p>
          <p>
            Los RSC invierten el control. Por defecto, los componentes se renderizan en el servidor. Esto significa:
          </p>
          <ul>
            <li>Tamaño de bundle cero para dependencias solo del servidor.</li>
            <li>Acceso directo a recursos backend (bases de datos, sistemas de archivos).</li>
            <li>División automática de código por ruta.</li>
          </ul>

          <blockquote>
            "Los Server Components permiten a los desarrolladores construir aplicaciones que abarcan el servidor y el cliente, combinando la rica interactividad de las aplicaciones del lado del cliente con el rendimiento mejorado del renderizado tradicional del servidor."
          </blockquote>

          <h2>Implementación de Código</h2>
          <p>
            Considera un escenario típico de obtención de datos. En el mundo del lado del cliente, podríamos usar <code class="text-xs">useEffect</code>. En el mundo RSC, el componente mismo puede ser async.
          </p>

          <pre><code class="language-tsx">// Server Component (app/page.tsx)
import &#123; db &#125; from '@/lib/db';

async function getData() &#123;
  const res = await db.query('SELECT * FROM posts');
  return res.rows;
&#125;

export default async function Page() &#123;
  const data = await getData();

  return (
    &lt;main&gt;
      &#123;data.map((post) =&gt; (
        &lt;PostCard key=&#123;post.id&#125; &#123;...post&#125; /&gt;
      ))&#125;
    &lt;/main&gt;
  );
&#125;</code></pre>

          <h2>Implicaciones de Rendimiento</h2>
          <p>
            El beneficio más inmediato es la reducción en First Contentful Paint (FCP). Al cambiar la lógica de renderizado al servidor, enviamos HTML al cliente antes. Sin embargo, la verdadera magia radica en las capacidades de <strong>streaming</strong>. React ahora puede transmitir partes de la UI a medida que están listas, evitando que las consultas lentas de base de datos bloqueen todo el renderizado de la página.
          </p>

          <h2>Conclusión</h2>
          <p>
            Si bien la curva de aprendizaje es pronunciada, los beneficios de React Server Components son innegables para aplicaciones a gran escala. Nos devuelve a la simplicidad del modelo request/response mientras mantiene la interactividad moderna que los usuarios esperan.
          </p>
        </div>

        <div class="mt-16 pt-10 border-t border-white/5 flex justify-between items-center">
          <div class="text-sm text-neutral-500">
            Compartir este artículo
          </div>
          <div class="flex gap-4">
            <button class="p-2 rounded-full bg-white/5 hover:bg-white/10 text-white transition-colors">
              <span class="iconify" data-icon="lucide:twitter" data-width="16"></span>
            </button>
            <button class="p-2 rounded-full bg-white/5 hover:bg-white/10 text-white transition-colors">
              <span class="iconify" data-icon="lucide:linkedin" data-width="16"></span>
            </button>
            <button class="p-2 rounded-full bg-white/5 hover:bg-white/10 text-white transition-colors">
              <span class="iconify" data-icon="lucide:link" data-width="16"></span>
            </button>
          </div>
        </div>
      </article>
    </div>
  </main>
</NewLayout>
